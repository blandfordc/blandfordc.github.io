<p>Here are my posts:</p>
1. **What Software Engineering is to Me (1/16/2017)** 
<p>With no personal influence, software engineering is to come up with, test, and use new code that is needed for certain projects in whatever field of interest they have. I know that they have to work with a team, often. They seem to set the base for the project, and work with the developers to see it come to fruition, and work through any potential bugs or other things they may have to fix. More personally, software engineering for me is a potential career. I came into Xavier with absolutely no experience in computer science last year, but wanted to test it out and see how it may go. I really enjoyed the first class, and so took another, and eventually also declared the major. Sometimes, I feel very behind compared to other people in the classes, who seem to have accomplished so much already, but I caught up quick, and am staying on pace and enjoying it.</p>
2. **Chapter 1 Reflection (1/16/2017)**
<p>Chapter 1 of _The Pragmatic Programmer_ had a lot of interesting points to think about when getting into this class, but these are a few that particularly stood out to me. From one of the first sections, it was interesting when they were talking about owning up to our mistakes. Clearly, we're all going to run into bugs and issues, and not finish things on time, and it's tempting to lie and make excuses, but the alternates presented were important. I liked where they said that you should tell your excuse to "someone else" (i.e. an inanimate object or a pet, so, for me, my fish, or my lizards, or my plastic ant I keep on my desk). This way, you're able to hear how ridiculous it may sound, and fix what you say to actually apply to your target audience - to provide options on how to fix what you've run into, instead of just making excuses on why it happened. In this same vein of errors getting out of hand and having to make excuses for them, the book suggested that you fix every error as you run into them, or else they can quickly get out of hand and too hard to fix. Doing this lets you focus on the big picture, which is also important for coding. This all seemed to culminate in an important point of while, yes, you need to proofread and think critically about everything you do, your code may not be perfect and bugless - it can just be good enough. Importantly pointed out in the book, the authors mention that this does not mean that the code is bad or poorly written or doesn't compile, but that it meets the standards of what it needs to do for you and the consumer, without solving added stress.</p>
<p>A smaller part of this chapter near the end listed a few goals which I found interesting in going forward in the field. Being in the program has already had me on track for a few of them, as they suggest to learn a language a year, and in the past almost two years I've been learning, in class I've been introduced to C++, Java, and Python, as well as teaching myself basics of html. This also keeps me in the requirements of taking classes, and participating in a group (sort of, though being more involved in it would be good), as well as knowing the current of what is happening, because that's what they try to teach us. On my own, I've done other goals that they recommended (as I did when I started teaching myself some other things to keep up in computer science), and so I thought it was interesting to see them explicitely stated, and liked to mark them, to remember going forward.</p>
3. **Chapter 2 Reflection (1/23/2017)**
<p>One of the first pieces of advice in the chapter was to be careful not to repeat yourself - and if you do, make it easy to edit all of the instances of this at once so nothing breaks. This was good advice in general, but I found it particularly interesting when it went on to explain that this duplication could have been done on purpose or on accident. I know that I've accidentally written basically the same thing in two places before, but the idea of it seeming like there was no other choice was interesting to me, to find where it was easiest not to be repetitive. This applied to the 'easy to duplicate portion', which it's easy to understand why that might be desired. I had never before heard the word orthogonality, so this section was interesting to read as well, as it applied to the way you'd carefully code to avoid duplication when you can, and makes it easier to avoid the risk you may face from that. In the testing section, it suggested certain places where you might look at the ortogonality, and how tests seem to apply themselves to helping with this. </p>
<p>The idea of building prototypes not necessarily out of code, but potentially even just from Post-It nodes was also something I found interesting, and potentially applicable in the chapter. That way, you can make sure that you actually focus on all of the correct details in order to bea ble to write the code easily once you've gotten started with it.  It's not something you're supposed to complete, but something to just get you started and understand where you're going.</p>
