<p>Here are my posts:</p>
1. **What Software Engineering is to Me (1/16/2017)** 
<p>With no personal influence, software engineering is to come up with, test, and use new code that is needed for certain projects in whatever field of interest they have. I know that they have to work with a team, often. They seem to set the base for the project, and work with the developers to see it come to fruition, and work through any potential bugs or other things they may have to fix. More personally, software engineering for me is a potential career. I came into Xavier with absolutely no experience in computer science last year, but wanted to test it out and see how it may go. I really enjoyed the first class, and so took another, and eventually also declared the major. Sometimes, I feel very behind compared to other people in the classes, who seem to have accomplished so much already, but I caught up quick, and am staying on pace and enjoying it.</p>
2. **Chapter 1 Reflection (1/16/2017)**
<p>Chapter 1 of _The Pragmatic Programmer_ had a lot of interesting points to think about when getting into this class, but these are a few that particularly stood out to me. From one of the first sections, it was interesting when they were talking about owning up to our mistakes. Clearly, we're all going to run into bugs and issues, and not finish things on time, and it's tempting to lie and make excuses, but the alternates presented were important. I liked where they said that you should tell your excuse to "someone else" (i.e. an inanimate object or a pet, so, for me, my fish, or my lizards, or my plastic ant I keep on my desk). This way, you're able to hear how ridiculous it may sound, and fix what you say to actually apply to your target audience - to provide options on how to fix what you've run into, instead of just making excuses on why it happened. In this same vein of errors getting out of hand and having to make excuses for them, the book suggested that you fix every error as you run into them, or else they can quickly get out of hand and too hard to fix. Doing this lets you focus on the big picture, which is also important for coding. This all seemed to culminate in an important point of while, yes, you need to proofread and think critically about everything you do, your code may not be perfect and bugless - it can just be good enough. Importantly pointed out in the book, the authors mention that this does not mean that the code is bad or poorly written or doesn't compile, but that it meets the standards of what it needs to do for you and the consumer, without solving added stress.</p>
<p>A smaller part of this chapter near the end listed a few goals which I found interesting in going forward in the field. Being in the program has already had me on track for a few of them, as they suggest to learn a language a year, and in the past almost two years I've been learning, in class I've been introduced to C++, Java, and Python, as well as teaching myself basics of html. This also keeps me in the requirements of taking classes, and participating in a group (sort of, though being more involved in it would be good), as well as knowing the current of what is happening, because that's what they try to teach us. On my own, I've done other goals that they recommended (as I did when I started teaching myself some other things to keep up in computer science), and so I thought it was interesting to see them explicitely stated, and liked to mark them, to remember going forward.</p>
