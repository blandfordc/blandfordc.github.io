<p>Here are my posts:</p>
1. **What Software Engineering is to Me (1/16/2017)** 
<p>With no personal influence, software engineering is to come up with, test, and use new code that is needed for certain projects in whatever field of interest they have. I know that they have to work with a team, often. They seem to set the base for the project, and work with the developers to see it come to fruition, and work through any potential bugs or other things they may have to fix. More personally, software engineering for me is a potential career. I came into Xavier with absolutely no experience in computer science last year, but wanted to test it out and see how it may go. I really enjoyed the first class, and so took another, and eventually also declared the major. Sometimes, I feel very behind compared to other people in the classes, who seem to have accomplished so much already, but I caught up quick, and am staying on pace and enjoying it.</p>
2. **Chapter 1 Reflection (1/16/2017)**
<p>Chapter 1 of _The Pragmatic Programmer_ had a lot of interesting points to think about when getting into this class, but these are a few that particularly stood out to me. From one of the first sections, it was interesting when they were talking about owning up to our mistakes. Clearly, we're all going to run into bugs and issues, and not finish things on time, and it's tempting to lie and make excuses, but the alternates presented were important. I liked where they said that you should tell your excuse to "someone else" (i.e. an inanimate object or a pet, so, for me, my fish, or my lizards, or my plastic ant I keep on my desk). This way, you're able to hear how ridiculous it may sound, and fix what you say to actually apply to your target audience - to provide options on how to fix what you've run into, instead of just making excuses on why it happened. In this same vein of errors getting out of hand and having to make excuses for them, the book suggested that you fix every error as you run into them, or else they can quickly get out of hand and too hard to fix. Doing this lets you focus on the big picture, which is also important for coding. This all seemed to culminate in an important point of while, yes, you need to proofread and think critically about everything you do, your code may not be perfect and bugless - it can just be good enough. Importantly pointed out in the book, the authors mention that this does not mean that the code is bad or poorly written or doesn't compile, but that it meets the standards of what it needs to do for you and the consumer, without solving added stress.</p>
<p>A smaller part of this chapter near the end listed a few goals which I found interesting in going forward in the field. Being in the program has already had me on track for a few of them, as they suggest to learn a language a year, and in the past almost two years I've been learning, in class I've been introduced to C++, Java, and Python, as well as teaching myself basics of html. This also keeps me in the requirements of taking classes, and participating in a group (sort of, though being more involved in it would be good), as well as knowing the current of what is happening, because that's what they try to teach us. On my own, I've done other goals that they recommended (as I did when I started teaching myself some other things to keep up in computer science), and so I thought it was interesting to see them explicitely stated, and liked to mark them, to remember going forward.</p>
3. **Chapter 2 Reflection (1/23/2017)**
<p>One of the first pieces of advice in the chapter was to be careful not to repeat yourself - and if you do, make it easy to edit all of the instances of this at once so nothing breaks. This was good advice in general, but I found it particularly interesting when it went on to explain that this duplication could have been done on purpose or on accident. I know that I've accidentally written basically the same thing in two places before, but the idea of it seeming like there was no other choice was interesting to me, to find where it was easiest not to be repetitive. This applied to the 'easy to duplicate portion', which it's easy to understand why that might be desired. I had never before heard the word orthogonality, so this section was interesting to read as well, as it applied to the way you'd carefully code to avoid duplication when you can, and makes it easier to avoid the risk you may face from that. In the testing section, it suggested certain places where you might look at the ortogonality, and how tests seem to apply themselves to helping with this. </p>
<p>The idea of building prototypes not necessarily out of code, but potentially even just from Post-It nodes was also something I found interesting, and potentially applicable in the chapter. That way, you can make sure that you actually focus on all of the correct details in order to bea ble to write the code easily once you've gotten started with it.  It's not something you're supposed to complete, but something to just get you started and understand where you're going.</p>
4. **Chapter 3 Reflection (Due 2/13/17)**
<p>Starting last semester, I used the command line for most things, even though I hadn't really used it before. It was confusing for a while, and I still forget the commands a lot, but since they're a simple Google away, and I'm used to it now, I often still use it. However, I was interested in the fact that the book had a section where they specifically talked about how they preferred command lines to GUIs, because of things a GUI might not support. This was sort of interesting to me, and made me more hopeful with my use of the command line, since learning it would assist in the long-run. </p>
<p>I also liked the section where it was talking about selecting a single editor and sticking to it â€“ I'm currently in a state of having multiple editors on my computers and just playing with certain features of each one. Even though it said nothing new, it was important to read that, yeah, maybe, I should focus into one editor. </p>
5. **12 Factor Reflection (Due 3/1/17)**
<p>Since Data Structures, we've been working with Git and BitBucket, so it wasn't really new news to find out that it works best to be able to have one code base for many people to work off of, rather than a buch of separate repositories. As it applies directly to another part of this week's homework, I thought that the logging section was interesting, espcially that they specificed that it was good for finding an app's behavior over time - this is obviously much different than a lot of the tests that we've done, since most functions we've run have been quickly run once and then ended immediately after we've gotten our result. The separation between the build, release, and run stages were also an interesting idea, as it helped me understand better what those meant in our code. For example, knowing that the build stage got the dependencies, while the release and run were more the stages that actually deployed the code was good to know.</p>
<p>Throughout a lot of the reading, however, I thought that some of the examples didn't really apply to things that I'd ever heard of, and so made it difficult to really understand what tehy were actually saying. The section on admin processes was especially confusing to me, I didn't really understand much at all of what they said in that section other than the very base level.</p>
6. **Mythical Man Month Reflection (Due 3/22/17)**
<p>It was on the first page of the reading that I knew that this chapter was talking to me. "I just found the last bug". I've come over the past two years to expect that fixing 'the last bug' will just trigger a thousand other bugs, but I still think about the fact that every time I fix one, it's got to be the last one. Page 20 of the reading, where it's talking about the schedule that the author uses also seemed interesting, beacuse it showed just how much time really had to go into it, and the fact that it wouldn't necessarily be mostly coding - and coding is actually a small part of it. That would make sense, because often the coding gets done relatively quickly in comparison with the rest of the work. Increasing the time of testing to half of the time that we spend working on things was something that I hadn't considered before, because it always seems that coding should take the most time, even though it usually doesn't. </p>
<p>In addition to that, they bring up the idea of trying to add more people to take down the time somethign make take. Adding more people to make things go faster is something I've wished could work in more than one field, and computer science seems like one where that would seem 'obvious', but at the same time, at some point, more people have to agree and work together, and so sometimes, that might end up taking more time if we were to add more and more people onto the project. I've more than once had a project that I thought wouldn't take very long and then with a mixture of all of the things they said (except the other people, because most projects to this point have been working alone), they ended up taking much longer than I thought they ever could.</p>
7. **Pragmatic Programmer Chapter 4**
<p>"It's much easier to find and diagnose the problem by crashing early, at the site of the problem." Chapter 4 of the Pragmatic Programmer is about making and meeting contracts so that our code runs and does as it is supposed to. A lot of the beginning of the chapter talks of things I already understand - that you are responsbile for the bugs in the code. DBC is not something I've herad about by name, but I think is something that we all use without really having to think about the name, the process of getting requirements, meeting the requirements, making sure the program does something, and making sure that it always does what it is supposed to do.Loop and Semantic Invariants are again things that I think I have done before, but never known a name for. I think the book, and experience makes it obvious that your code has to be catered to the consumer, not to yourself. Though I've heard it before, the idea of crashing your code often to find the broken pieces, but it was nice for the book to say it again for me.</p>
<p>I don't think I've ever been taught exactly what exceptions are, so reading the section on when they suggest to throw an exception was interesting and informative. We talked about balancing resources a little last semester, but it was still good to have the refreasher and another source's suggestions.</p>
8. **Pragmatic Programmer Chapter 5**
<p>At first, I was confused on what they were talking about in avoiding coupling, but it's the same concept we've been using this year with our structures for our code. We don't want someone to have to dig through a bunch of code to call upon a hierarchy in order to make it run, but instead for the code to be able to run within itself, because all of the calls are either separated or within the code, and only going down a layer, instead of multiple. I've never heard of the Law of Demeter before, but it makes sense if we're trying to avoid complexities in code that will cause it to break more often. A lot in the metadata/metaprogramming section seemed to fit into this same project format we've been using all semester - to keep the business in its own section of code, away from everything else. Some of this chapter seemed repetitive, but overall, it was good information on how to keep the code looking clean, which is something I've only vaguely consdeired before this class. In this class, we've started to separate things more than just into separate classes, and so that makes cleaner looking code, and I feel like that's a lot about what this chapter was about.</p>
<p>While not necessarily an academic review of this chapter, I really enjoyed all of the charts that they had in it to explain what they were talking about. I thought that they were actually very useful to see exactly what was going on within the text of the chapters, especially where there was no example code to lead us along the way.</p>
9. **Pragmatic Programmer Chapter 6**
<p>Programming deliberately, and not by hope of something that happened to work once is something that logically makes sense, and something that we've talked about before, because you need to know what your code is doing. If you don't know what your code does, how will anyone understand what your code does (including yourself, a few years, or even weeks, along the line)? We talked a lot about runtime last semester in Data Structures, so I didn't need to read that section very closely to understand what it was talking about. Interesting, though, was the end of that section, where it went on to say that the best code may not be the one with the best runtime. Refactoring, again, I think is something that we talk about in classes and in logical coding, but never necessarily put a name to, or give a designated time within our process of learning and coding. We've also been doing a lot of test-based programming this semester, so I thought that the sections about testing, while interesting and necessarily, were rather reptitive for people in this class.</p>
<p>Overall, this chapter presented a lot of important information for a programmer, but they happened to be many things that we'd already learned in past classes, and so not as necessary to focus in on while I was reading through.</p>
10. **Pragmatic Programmer Chapter 7**
<p>Again in this chapter, I thought that the diagrams and charts were really helpful in their explanations. When you're talking about something that has to be detail-oriented (but not so much so, as the section warns, too many requirements or too specific ones will hurt the project), the detailed examples are also important. A project glossary was an interesting idea that they brought up partially through the chapter, somewhere where everything about the project is easily accessible. It seems like something that may be more common sense on a work force than in a school setting, but it was an interesting thing to begin to think about - how to make code and projects friendly for a team of people working on it, not just yourself. We've been doing that, obviously, with the project, but moving forward, that will be a lot of what we need to do, so starting with some ideas of how best to accomplish these things is important. </p>
<p>Finding an easy way out of problems is not always logical, but it could work sometimes. Sometimes, when you have a bug, it makes you angry, and you just overthink until you're too frustrated to continue to code. By instead starting by looking for an easier solution, you might save yourself some frustration time (though, I want to say that this method will not always work). I also liked that they brought up that there was a difference between procrastinating and just being unable to start - I am a victim to both of them, but I like that it was addressed that they were different. </p>
11. **Pragmatic Programmer Chapter 8**
<p>Team work has been the end of this semester for us, with our time tracking project, and I think that this chapter wasn't necessarily new information, but essential in moving into the work force, away from academic settings in which these things are necessary. Many of these have made themselves blaringly necessary in our project, but I think the number one that will need to be worked on moving forward is communication - I felt like my main trouble with the project was making sure to communicate with my team and making sure that they communicated with me, rather than a lot of the coding that we were doing. While it won't be the same for every team, how well we work together, it's still vitally important to make sure that communication stays constant and on topic, to keep things on track. Talking about testing again is important, because tests are a fundamental part of coding - without testing, you can do practically nothing, because chances are everything is broken until you run it through a test or two (or at the very least a compiler) to try to catch some of your errors. The chapter suggesting to test early, often, and to test everything were very important suggestions that I feel we've been working toward this semester, if we haven't fully developed these habits yet. </p>
<p>I try to put a lot of comments and well named variables in my code so I can understand what I've programmed, but the reminder that this is necessary for everyone who may look at it is also important. We're all people, and moving into the work force, we're going to have to be using the skills that this book was trying to develop.</p>
