<p>Here are my posts:</p>
1. **What Software Engineering is to Me (1/16/2017)** 
<p>With no personal influence, software engineering is to come up with, test, and use new code that is needed for certain projects in whatever field of interest they have. I know that they have to work with a team, often. They seem to set the base for the project, and work with the developers to see it come to fruition, and work through any potential bugs or other things they may have to fix. More personally, software engineering for me is a potential career. I came into Xavier with absolutely no experience in computer science last year, but wanted to test it out and see how it may go. I really enjoyed the first class, and so took another, and eventually also declared the major. Sometimes, I feel very behind compared to other people in the classes, who seem to have accomplished so much already, but I caught up quick, and am staying on pace and enjoying it.</p>
2. **Chapter 1 Reflection (1/16/2017)**
<p>Chapter 1 of _The Pragmatic Programmer_ had a lot of interesting points to think about when getting into this class, but these are a few that particularly stood out to me. From one of the first sections, it was interesting when they were talking about owning up to our mistakes. Clearly, we're all going to run into bugs and issues, and not finish things on time, and it's tempting to lie and make excuses, but the alternates presented were important. I liked where they said that you should tell your excuse to "someone else" (i.e. an inanimate object or a pet, so, for me, my fish, or my lizards, or my plastic ant I keep on my desk). This way, you're able to hear how ridiculous it may sound, and fix what you say to actually apply to your target audience - to provide options on how to fix what you've run into, instead of just making excuses on why it happened. In this same vein of errors getting out of hand and having to make excuses for them, the book suggested that you fix every error as you run into them, or else they can quickly get out of hand and too hard to fix. Doing this lets you focus on the big picture, which is also important for coding. This all seemed to culminate in an important point of while, yes, you need to proofread and think critically about everything you do, your code may not be perfect and bugless - it can just be good enough. Importantly pointed out in the book, the authors mention that this does not mean that the code is bad or poorly written or doesn't compile, but that it meets the standards of what it needs to do for you and the consumer, without solving added stress.</p>
<p>A smaller part of this chapter near the end listed a few goals which I found interesting in going forward in the field. Being in the program has already had me on track for a few of them, as they suggest to learn a language a year, and in the past almost two years I've been learning, in class I've been introduced to C++, Java, and Python, as well as teaching myself basics of html. This also keeps me in the requirements of taking classes, and participating in a group (sort of, though being more involved in it would be good), as well as knowing the current of what is happening, because that's what they try to teach us. On my own, I've done other goals that they recommended (as I did when I started teaching myself some other things to keep up in computer science), and so I thought it was interesting to see them explicitely stated, and liked to mark them, to remember going forward.</p>
3. **Chapter 2 Reflection (1/23/2017)**
<p>One of the first pieces of advice in the chapter was to be careful not to repeat yourself - and if you do, make it easy to edit all of the instances of this at once so nothing breaks. This was good advice in general, but I found it particularly interesting when it went on to explain that this duplication could have been done on purpose or on accident. I know that I've accidentally written basically the same thing in two places before, but the idea of it seeming like there was no other choice was interesting to me, to find where it was easiest not to be repetitive. This applied to the 'easy to duplicate portion', which it's easy to understand why that might be desired. I had never before heard the word orthogonality, so this section was interesting to read as well, as it applied to the way you'd carefully code to avoid duplication when you can, and makes it easier to avoid the risk you may face from that. In the testing section, it suggested certain places where you might look at the ortogonality, and how tests seem to apply themselves to helping with this. </p>
<p>The idea of building prototypes not necessarily out of code, but potentially even just from Post-It nodes was also something I found interesting, and potentially applicable in the chapter. That way, you can make sure that you actually focus on all of the correct details in order to bea ble to write the code easily once you've gotten started with it.  It's not something you're supposed to complete, but something to just get you started and understand where you're going.</p>
4. **Chapter 3 Reflection (Due 2/13/17)**
<p>Starting last semester, I used the command line for most things, even though I hadn't really used it before. It was confusing for a while, and I still forget the commands a lot, but since they're a simple Google away, and I'm used to it now, I often still use it. However, I was interested in the fact that the book had a section where they specifically talked about how they preferred command lines to GUIs, because of things a GUI might not support. This was sort of interesting to me, and made me more hopeful with my use of the command line, since learning it would assist in the long-run. </p>
<p>I also liked the section where it was talking about selecting a single editor and sticking to it â€“ I'm currently in a state of having multiple editors on my computers and just playing with certain features of each one. Even though it said nothing new, it was important to read that, yeah, maybe, I should focus into one editor. </p>
5. **12 Factor Reflection (Due 3/1/17)**
<p>Since Data Structures, we've been working with Git and BitBucket, so it wasn't really new news to find out that it works best to be able to have one code base for many people to work off of, rather than a buch of separate repositories. As it applies directly to another part of this week's homework, I thought that the logging section was interesting, espcially that they specificed that it was good for finding an app's behavior over time - this is obviously much different than a lot of the tests that we've done, since most functions we've run have been quickly run once and then ended immediately after we've gotten our result. The separation between the build, release, and run stages were also an interesting idea, as it helped me understand better what those meant in our code. For example, knowing that the build stage got the dependencies, while the release and run were more the stages that actually deployed the code was good to know.</p>
<p>Throughout a lot of the reading, however, I thought that some of the examples didn't really apply to things that I'd ever heard of, and so made it difficult to really understand what tehy were actually saying. The section on admin processes was especially confusing to me, I didn't really understand much at all of what they said in that section other than the very base level.</p>
6. **Mythical Man Month Reflection (Due 3/22/17)**
<p>It was on the first page of the reading that I knew that this chapter was talking to me. "I just found the last bug". I've come over the past two years to expect that fixing 'the last bug' will just trigger a thousand other bugs, but I still think about the fact that every time I fix one, it's got to be the last one. Page 20 of the reading, where it's talking about the schedule that the author uses also seemed interesting, beacuse it showed just how much time really had to go into it, and the fact that it wouldn't necessarily be mostly coding - and coding is actually a small part of it. That would make sense, because often the coding gets done relatively quickly in comparison with the rest of the work. Increasing the time of testing to half of the time that we spend working on things was something that I hadn't considered before, because it always seems that coding should take the most time, even though it usually doesn't. </p>
<p>In addition to that, they bring up the idea of trying to add more people to take down the time somethign make take. Adding more people to make things go faster is something I've wished could work in more than one field, and computer science seems like one where that would seem 'obvious', but at the same time, at some point, more people have to agree and work together, and so sometimes, that might end up taking more time if we were to add more and more people onto the project. I've more than once had a project that I thought wouldn't take very long and then with a mixture of all of the things they said (except the other people, because most projects to this point have been working alone), they ended up taking much longer than I thought they ever could.</p>
